# -*- coding: utf-8 -*-
"""Projeto_NGI_Debora_Mendes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q_hy1wxdStOIr0Q1cEL8yAFrvxV-IvYL

##Importando bibliotecas
"""

import pandas as pd
import requests
import kagglehub #
import os
import numpy as np
import re
import sqlite3

"""## Download do Dataset Disney"""

# Download do Dataset Dysney Movies and TV Shows

path = kagglehub.dataset_download("shivamb/disney-movies-and-tv-shows")
print("Path to dataset files:", path)

print(os.listdir(path))

df_disney_raw = pd.read_csv(os.path.join(path + "/disney_plus_titles.csv"))
df_disney_raw.head()

"""## Tratamento de Dados

### Estatísticas
"""

df_disney_raw.describe()

df_disney_raw.info()

# Valores distintos na coluna 'show_id'
num_id = df_disney_raw['show_id'].nunique()
print(f"Há {num_id} valores distintos na coluna show_id")

"""## Limpeza e Tratamento dos Dados"""

df_disney = df_disney_raw.copy()

# coluna de primary key
df_disney['id_pk'] = df_disney.index + 1

# Quantidade de valores nulos nas colunas do Dataset
df_disney.isnull().sum()

# Quantidade de linhas duplicadas
df_disney.duplicated().sum()

# Substitui valores nulos (NaN) por desconhecido (Unknow)
df_disney['director'].fillna('Unknown', inplace=True)
df_disney['cast'].fillna('Unknown', inplace=True)
df_disney['country'].fillna('Unknown', inplace=True)
df_disney['rating'].fillna('Unrated', inplace=True)

df_disney.head(20)

def extrair_unidade_e_valor(duration_str):
        if pd.isna(duration_str):
            return (None, None)
        duration_str = str(duration_str).strip()

        unidade = None
        if 'min' in duration_str:
            unidade = 'min'
        elif 'Season' in duration_str:
            unidade = 'Season'
        elif 'Seasons' in duration_str:
            unidade = 'Seasons'
        else:
            return (None, None)

        match = re.search(r'(\d+)', duration_str)
        valor = int(match.group(1)) if match else None

        return (unidade, valor)

# Criar as novas colunas
df_disney[['duration_unit', 'duration_value']] = df_disney['duration'].apply(
        lambda x: pd.Series(extrair_unidade_e_valor(x))
    )
df_disney.rename(columns={'type': 'content_type'}, inplace=True)
df_disney.drop(columns=['duration', 'description'], inplace=True)

colunas_finais = [
        'id_pk', 'content_type', 'title', 'director', 'cast', 'country',
        'date_added', 'release_year', 'rating', 'duration_value',
        'duration_unit', 'listed_in'
    ]
df_disney_sql = df_disney[colunas_finais].copy()

df_disney_sql.head(20)

df_disney_sql.info()

df_disney_sql['date_added'] = pd.to_datetime(df_disney_sql['date_added'])
df_disney_sql['duration_value'] = df_disney['duration_value'].astype(float)
df_disney_sql.info()

df_disney_sql.describe()

df_disney_sql.head(20)

"""### Criando tabela 2 tabelas de acordo com o tipo de stream (Movie or TV Show)"""

df_disney_movie_sql = df_disney_sql[df_disney_sql['content_type'] == 'Movie']
df_disney_serie_sql = df_disney_sql[df_disney_sql['content_type'] == 'TV Show']

df_disney_movie_sql.head(15)

df_disney_serie_sql.head(10)

"""## Carregamento dos dados SQLite"""

DISNEY_DB = 'disney_etl_project.db'
DISNEY_TABLE = 'conteudo_disney'

conn = sqlite3.connect(DISNEY_DB)

print(f"\nCarregando dados na tabela '{DISNEY_TABLE}' do banco '{DISNEY_DB}'...")

df_disney_sql.to_sql(DISNEY_TABLE, conn, if_exists='replace', index=False)

conn.execute(f"CREATE UNIQUE INDEX idx_id_pk ON {DISNEY_TABLE} (id_pk);")

conn.commit()
conn.close()

print("Carregamento e Criação do Banco SQLite concluídos com sucesso.")

"""## Consulta SQL"""

# --- 3. EXECUTANDO CONSULTAS SQL ---
print("\n--- 3. EXECUTANDO CONSULTAS SQL ---")

DISNEY_DB = 'disney_etl_project.db'
DISNEY_TABLE = 'conteudo_disney'

try:
    conn = sqlite3.connect(DISNEY_DB)

    # Consulta 1: Filmes COM DURAÇÃO > 90min e de diretores populares
    query_1 = f"""
    WITH DiretoresPopulares AS (
        -- Identifica diretores com 5 ou mais Filmes e duração média > 90 min
        SELECT
            director
        FROM
            {DISNEY_TABLE}
        WHERE
            content_type = 'Movie'
            AND duration_unit = 'min'
            AND director <> 'Unknown' -- Ignora diretores desconhecidos
        GROUP BY
            director
        HAVING
            COUNT(id_pk) >= 5
            AND AVG(duration_value) > 90
    )

    SELECT
        T1.title,
        T1.director,
        T1.release_year,
        T1.duration_value AS runtime_minutos
    FROM
        {DISNEY_TABLE} AS T1
    JOIN
        DiretoresPopulares AS T2 ON T1.director = T2.director
    WHERE
        T1.content_type = 'Movie'
    ORDER BY
        T1.director, T1.release_year DESC
    LIMIT 10;
    """
    print("\n[Consulta 1] Top 10 dos filmes longos com diretores populares:")
    print(pd.read_sql_query(query_1, conn))


    # Consulta 2: Tendência de Lançamento por Gênero (Foco em Animação)
    query_2 = f"""
    SELECT
        release_year,
        content_type,
        COUNT(id_pk) AS total_titulos_ano,
        SUM(CASE WHEN listed_in LIKE '%Animation%' THEN 1 ELSE 0 END) AS total_animacao,
        -- Calcula o percentual de títulos de animação
        ROUND(CAST(SUM(CASE WHEN listed_in LIKE '%Animation%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id_pk), 2) AS percentual_animacao
    FROM
        {DISNEY_TABLE}
    WHERE
        release_year >= 2010
    GROUP BY
        release_year, content_type
    ORDER BY
        release_year DESC, content_type;
    """
    print("\n[Consulta 2] Tendência de Títulos Lançados (Pós-2010) com Foco em Animação:")
    print(pd.read_sql_query(query_2, conn))

    # --- CONSULTA 3: Distribuição de Duração por Classificação (Rating) ---
    query_3 = f"""
    SELECT
        rating,
        COUNT(id_pk) AS total_filmes,
        ROUND(AVG(duration_value), 2) AS duracao_media_minutos,
        MIN(duration_value) AS duracao_minima_minutos,
        MAX(duration_value) AS duracao_maxima_minutos
    FROM
        {DISNEY_TABLE}
    WHERE
        content_type = 'Movie'
        AND duration_unit = 'min'
        AND release_year >= 2010 -- Focando em filmes mais recentes
    GROUP BY
        rating
    HAVING
        COUNT(id_pk) > 5 -- Exclui classificações com poucas amostras
    ORDER BY
        duracao_media_minutos DESC;
    """
    print("\n[Consulta 3] Duração Média de Filmes (Pós-2010) por Classificação Indicativa:")
    print(pd.read_sql_query(query_3, conn))

  # --- Consulta 4: Programas de TV com MAIOR número de Temporadas ---

    query_max_seasons = f"""
    SELECT
        title,
        duration_value AS total_seasons,
        release_year,
        listed_in AS generos
    FROM
        {DISNEY_TABLE}
    WHERE
        content_type = 'TV Show'
        AND duration_unit = 'Season' -- Garante que estamos olhando para temporadas e não minutos
    ORDER BY
        duration_value DESC -- Ordena do maior para o menor
    LIMIT 5; -- Mostra os 5 programas de TV com mais temporadas (pode haver empate)
    """
    print("\n[Consulta 4] Programas de TV com MAIOR Número de Temporadas:")
    print(pd.read_sql_query(query_max_seasons, conn))


    # --- Consulta 5: Programas de TV com MENOR número de Temporadas ---
    # Usamos uma subconsulta para garantir que o menor valor encontrado é o 1 (o valor mínimo esperado).
    query_min_seasons = f"""
    SELECT
        title,
        duration_value AS total_seasons,
        release_year,
        listed_in AS generos
    FROM
        {DISNEY_TABLE}
    WHERE
        content_type = 'TV Show'
        AND duration_unit = 'Season'
        AND duration_value IS NOT NULL
        AND duration_value = (
            -- Subconsulta para encontrar o valor mínimo real (que deve ser 1)
            SELECT MIN(duration_value)
            FROM {DISNEY_TABLE}
            WHERE content_type = 'TV Show' AND duration_unit = 'Season'
        )
    ORDER BY
        release_year DESC -- Ordena por ano de lançamento para ver os mais recentes
    LIMIT 5; -- Mostra 5 exemplos de programas com o número mínimo de temporadas
    """
    print("\n[Consulta 5] Programas de TV com MENOR Número de Temporadas:")
    print(pd.read_sql_query(query_min_seasons, conn))

    conn.close()

except sqlite3.OperationalError as e:
    print(f"ERRO DE CONEXÃO: Certifique-se de que a Célula 2 (ETL) foi executada com sucesso. Erro: {e}")